import itertools
import torch


def permutation_group(x: torch.Tensor) -> torch.tensor:
    """Generate all permutations of elements in x.
    
    Parameters
    ----------
    x : torch.Tensor
        A tensor of shape (..., n, d).
        
    Returns
    -------
    torch.Tensor
        A tensor of shape (..., G, n, d) where G is the number of permutations of the elements in x.
    """
    indices = range(x.shape[-1])
    # TODO: There will be a way to do this using permutation matrices, which can be created on the GPU
    permuted_indices = [list(p) for p in itertools.permutations(indices)]
    permuted_x = x[..., permuted_indices]
    # permuted_x is a tensor of shape (..., n, G, d)
    # Reorder the dimensions to (..., G, n, d)
    dim_indices = list(range(permuted_x.dim()))
    dim_indices[-2], dim_indices[-3] = dim_indices[-3], dim_indices[-2]
    return permuted_x.permute(*dim_indices)


def block_permutation_group(x: torch.Tensor, block_size: int) -> torch.tensor:
    """Generate all permutations of blocks of elements in x.
    
    Parameters
    ----------
    x : torch.Tensor
        A tensor of shape (..., n, d).
    block_size : int
        The size of the blocks to permute. Must be a divisor of the last dimension of x.
        
    Returns
    -------
    torch.Tensor
        A tensor of shape (..., G, n, d) where G is the number of permutations of blocks of length block_size in x.
    """
    if x.shape[-1] % block_size != 0:
        raise ValueError(
            "Last dimension of x must be a multiple of block size"
            f" (got {x.shape[-1]} and {block_size} respectively)."
        )

    block_indices = [
        range(i, i + block_size) for i in range(0, x.shape[-1], block_size)
    ]
    # TODO: There will be a way to do this using permutation matrices, which can be created on the GPU
    # Use itertools.chain to flatten the list of lists generated by the permutation
    permuted_indices = [
        list(itertools.chain.from_iterable(p))
        for p in itertools.permutations(block_indices)
    ]
    permuted_x = x[..., permuted_indices]
    # permuted_x is a tensor of shape (..., n, G, d)
    # Reorder the dimensions to (..., G, n, d)
    dim_indices = list(range(permuted_x.dim()))
    dim_indices[-2], dim_indices[-3] = dim_indices[-3], dim_indices[-2]
    return permuted_x.permute(*dim_indices)


def cyclic_group(x: torch.Tensor) -> torch.Tensor:
    """Generate all cyclic permutations of elements in x.
    
    Parameters
    ----------
    x : torch.Tensor
        A tensor of shape (..., n, d).
        
    Returns
    -------
    torch.Tensor
        A tensor of shape (..., n, n, d) containing the cyclic permutations of x.
    """
    d = x.shape[-1]
    # TODO: There's a way to do this with torch.roll or permutation matrices, which would be faster
    permuted_indices = [
        list(range(i, d)) + list(range(i))
        for i in range(d)
    ]
    permuted_x = x[..., permuted_indices]
    # permuted_x is a tensor of shape (..., n, G, d)
    # Reorder the dimensions to (..., G, n, d)
    dim_indices = list(range(permuted_x.dim()))
    dim_indices[-2], dim_indices[-3] = dim_indices[-3], dim_indices[-2]
    return permuted_x.permute(*dim_indices)