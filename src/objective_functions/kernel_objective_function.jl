using AbstractGPs # For general GP functionality
using ParameterHandling
using Random, Distributions

"""
    build_latent_function(gp_builder_function, θ, D, n_points, seed)

Create a persistent function that is generated by a one-off random draw from a GP with the specified architecture and hyperparameters.

# Arguments
- `gp_builder_function::Function`: A function that takes a hyperparameter vector θ and returns a GP.
- `θ::NamedTuple`: The hyperparameters of the GP.
- `n_points::UInt`: The number of points to use to generate the latent function. Higher values will give more complex functions, at the cost of increased computational time.
- `bounds::Vector{Tuple{Float64, Float64}}`: The bounds used to generate the sample points. bounds should be a vector of length D, where D is the dimensionality of the input space. Each element of bounds should be a tuple of the form (lower_bound, upper_bound).
- `seed::UInt`: The seed for the random number generator.

# Returns
- `f::Function`: A function that maps from R^D to R.
"""
function build_latent_function(gp_builder_function::Function, θ::NamedTuple, n_points::Int, bounds::Vector{Tuple{Float64,Float64}}, seed::Int)::Function

    # Create a GP with the specified architecture and hyperparameters
    base_gp = gp_builder_function(θ)

    # Reseed the RNG every time, to ensure we get the same function
    dummy_rng = MersenneTwister(seed)

    # Generate the sample points
    distribution = [Uniform(lower, upper) for (lower, upper) in bounds]
    x = [rand.(dummy_rng, distribution) for _ in 1:n_points]

    # Observe values of a random sample from the GP evaluated at the sample locations
    # We do this to ensure that the resulting function can be represented by the GP
    y = rand(dummy_rng, base_gp(x, θ.σ_n^2 + 1e-6))

    # Condition the GP on the values at those points, treating them as noiseless observations
    true_gp = posterior(base_gp(x, 1e-6), y)

    # Define the latent function
    # Again, no noise, because this is the "ground truth" generative process
    # If you want to add noise, create an additional function that adds noise to the output of this function
    function f(x::Vector{Vector{Float64}})::Vector{Float64}
        return mean(true_gp(x, 1e-6))
    end
    f(x::Vector{Float64}) = only(f([x]))

    return f
end